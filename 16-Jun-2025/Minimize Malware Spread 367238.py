# Problem: Minimize Malware Spread - https://leetcode.com/problems/minimize-malware-spread/

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
    
        # Union-Find
        parent = [i for i in range(n)]

        def find(x):
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x

        def union(x, y):
            parent[find(x)] = find(y)

        # 1. Union connected nodes
        for i in range(n):
            for j in range(n):
                if graph[i][j] == 1:
                    union(i, j)

        # 2. Count size of each component
        size = [0] * n
        for i in range(n):
            root = find(i)
            size[root] += 1

        # 3. Count number of initial infected nodes in each component
        infected_count = [0] * n
        for node in initial:
            root = find(node)
            infected_count[root] += 1

        # 4. Try removing each node and calculate how many nodes can be saved
        result = float('inf')
        max_saved = -1
        for node in sorted(initial):  # sort to handle smallest index tie
            root = find(node)
            if infected_count[root] == 1:
                # Can save all uninfected nodes in the component
                if size[root] > max_saved:
                    max_saved = size[root]
                    result = node
                elif size[root] == max_saved and node < result:
                    result = node

        return result if result != float('inf') else min(initial)